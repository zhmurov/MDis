/** \page page4 Системы единиц
 
\section motivation Мотивация
Начнём с примера. Пусть имеется задача:
\code
m * d2x/dt2 + k * x, x(0) = x0
\endcode
Причём поставлена она в абстрактной форме без какой бы то ни было интерпретации переменных.
Ничто не мешает приписать x некую размерность: [x] = X и так далее [t] = T, [m] = M, [k] = M/(T^2)
Размерности [x], [t], [m] задаются произвольно, а [k] выбирается так чтобы слагаемые в нашем уравнении измерялись в одних единицах.

Но всё это не более чем мнемонический приём, который помогает понять какой группе преобразование инвариантно уравнение.
В данном случае уравнение инвариантно к заменам переменных:
\code
x = a * x',    a>0
m = b * m',    b>0
t = c * t',    c>0
k = [b / (c^2)] * k'
\endcode
Что прозрачно соответствует размерностям: X <=> a, M <=> b, T <=> c, M/T^2 <=> b/c^2.
Если проделать замену, после упрощения получаем тоже самое уравнение:
\code
m' * d2x'/dt'2 + k' * x', x'(0) = x0'
\endcode
Таким образом назвав это преобразование, при конкретных значениях a, b и c, преобразованием системы единиц, можно утверждать, что это уравнение не зависит от того в каких единицах измеряются величины.

\section theory Теоретическая часть 
Замечательно то, что если расширить эту систему уравнений до 7 переменных (плюс по уравнению на каждую константу с собственной размерностью) и записать не только закон Гука, а все остальные интересующие формулы, то все они окажутся одновременно инвариантны относительно любого конкретного преобразования из такой группы.
Это обстоятельство позволяет записывать уравнения (а также расчётные формулы в программе) не думая о системе единиц. Получается что в любой системе единиц уравнения будут одинаковы.

Почему это не согласуются с реальностью? в СГС и СИ разные формулы?
В СГС основными считаются 3 величины. В СИ были дополнительно введены основные единицы для электромагнитных физических величин, которых не было в СГС, потому некоторые единицы имеют другие размерности.
В симметричной СГС (называемой также смешанной СГС или Гауссовой системой единиц) магнитная и электрическая постоянные единичные и безразмерные: mu0 = 1, eps0 = 1
Из формул mu0 = 1, eps0 = 1 и извлекаются коффициенты преобразования между системами. На эту тему есть много вариаций - но всегда можно перевести одну формулу в другую.
Таким образом, есть ещё одна возможность абстрагирования, которая не учитывается нашей реализацией.
Сами размерости одной и той же величины могут быть различны. В нашей реализации они всегда одинаковы.
И поскольку изначально размерности вводятся произвольно, различные системы единиц могут брать базовыми другой набор величин.
Хотя сложно представить систему в которой нет базовой единицы измерения расстояния, но сила тока с лёгкостью заменяется зарядом.
Это для нас не принципиально, так как размерность силы тока всё равно не пропадает - просто она перестаёт быть базовой.

Как имея формулу записанную в СГС, получить формулу для СИ? Эта проблема решается просто. Берётся формула в СГС, а размерности величин в СИ и оказывается, что размерности не согласуются, тогда становиться совершенно понятно в каких именно местах пропущенны коэффициенты, каковы их размерности и каково их значение в системе СГС. В этих местах как правило восстанавливаются комбинации универсальных констант, но это даже не обязательно, так как значения коэффициента и его размерности достаточно, чтобы формулу можно было записать универсально - просто передавать ей значение этого коэффициента преобразованное в систему согласованную с остальными переменными в формуле.

Записывать формулы надо в системе СИ. Если формулы даны не в СИ - надо восстанавливать коэффициенты по размерности.
Но это не значит что расчёт будет в единицах СИ, а значит только то, что мы используем ровно 7 основных величин.

Класс UnitsSystem задаёт логарифмированные коэфициенты преобразования базовых единиц: длины, массы, времени, силы тока, температуры и количества вещества.
В примере это логарифмы чисел a, b и c. Имея эти коэфициенты и зная размерность величины можно легко получить значение этой величины в новой системе единиц.
Преобразование всегда будет задаваться выражением вида:
\code
v = a^ao * b^bo * c^co * ... * v'
\endcode 
здесь v - значение величины в старой системе, v' - в новой, ao, bo, co - задают размерность преобразовываемой величины.
Отсюда для логарифмированных коэффициентов имеем:
\code
v = exp(ln(a)*ao + ln(b)*bo + ln(c)*co + ...) * v'
v = exp(coef * quantity) * v'
\endcode
здесь coef - вектор логарифмированных коэффициентов {ln(a), ln(b), ln(c), ...}, quantity - вектор порядков основных единиц входящих в размерность величины или просто размерность величины.
Таким образом коэффициент перехода - есть экспонента от скалярного произведения размерности величины на вектор коффициентов преобразования базовых единиц.
Получается, что UnitsSystem задаёт преобразование между двумя системами единиц. Чтобы перейти от описание преобразований одну из систем единиц приходится взять за точку отсчёта.
В качестве такой точки часто берётся система СИ, т.е. UnitsSystem - это преобразование от системы СИ к некой новой системе единиц, которую UnitsSystem и описывает.

Теперь рассмотрим преобразование G величины v размерности V из системы X в систему Y.
\code
v[X] = exp(G*V) * v[Y]
v[si] = exp(X*V) * v[X]
v[si] = exp(Y*V) * v[Y]
v[X] = exp(-X*V) * v[si] = exp(-X*V) * exp(Y*V) * v[Y] = exp((Y-X)*V) * v[Y]
G = Y - X
\endcode

\section implementation Реализация
Общие физические/химические/биологические константы задются в Constants.h, например для электрической постоянной:
\code
DEFINE_CONSTANT(Electric, si, 8.854187817620e-12, -3*_L-_M+4*_T+2*_I)
\endcode
Это обозначает, что электрическая постоянная имеет размерность L^-3*M^-1*T^4*I^2 и в системе СИ имеет значение 8.854187817620e-12
Чтобы получить её значение в другой системе, которая задана объектом:
\code
UnitsSystem my_system;
\endcode
надо сделать так:
\code
float value_in_my_system = constant::Electric(my_system);
\endcode

Для преобразования произвольной величины с заданной размерностью:
\code
float value_in_new_system = unitssystem::Convert(old_system, new_system, value_in_old_system, quantity);
\endcode

Использование сохраненных чисел вместо виличин ангстрем, Дж и т.п. позволяет избежать громоздких обращений к функциям преобразования и делает читабельным:
\code
float angstrom = unitssystem::Convert(my_system, 1e-10f, _L);
float joule = unitssystem::Convert(my_system, 1.0f, _Energy);
float nanometre = 10 * angstrom;
float hundred_joules = 100 * joules;
float my_distance = 123 * angstrom;
float my_force = 13 * hundred_joles;
float my_second_force = 15 * hundred_joles;
float my_third_force = 567 * joles;
\endcode

Размерность величины - элемент линейного пространства R^6 с базисом {_L, _M, _T, _I, _K, _N}
Для удобства вместо умножения используется сложение и вместо возведения в степень - умножение.
Например выражение L^1 * T^(-2) надо записывать как  _L - 2*_T.

Определение Quantity:
\code
static const int QuantityDim = 6;
typedef Vector<double, QuantityDim> Quantity;
\endcode
Поэтому можно использовать весь арсенал линейной алгебры из LinearAlgebra.h

*/
